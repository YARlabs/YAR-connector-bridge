{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/introspection/IERC165.sol\";\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/diamond_base/Diamond.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.8.17;\r\n\r\nimport { LibDiamond } from \"./libraries/LibDiamond.sol\";\r\nimport { IDiamondCut } from \"./interfaces/IDiamondCut.sol\";\r\n\r\ncontract Diamond {    \r\n    constructor(address _contractOwner, address _diamondCutFacet) payable {        \r\n        LibDiamond.setContractOwner(_contractOwner);\r\n\r\n        // Add the diamondCut external function from the diamondCutFacet\r\n        IDiamondCut.FacetCut[] memory cut = new IDiamondCut.FacetCut[](1);\r\n        bytes4[] memory functionSelectors = new bytes4[](1);\r\n        functionSelectors[0] = IDiamondCut.diamondCut.selector;\r\n        cut[0] = IDiamondCut.FacetCut({\r\n            facetAddress: _diamondCutFacet, \r\n            action: IDiamondCut.FacetCutAction.Add, \r\n            functionSelectors: functionSelectors\r\n        });\r\n        LibDiamond.diamondCut(cut, address(0), \"\");        \r\n    }\r\n\r\n    // Find facet for function that is called and execute the\r\n    // function if a facet is found and return any value.\r\n    fallback() external payable {\r\n        LibDiamond.DiamondStorage storage ds;\r\n        bytes32 position = LibDiamond.DIAMOND_STORAGE_POSITION;\r\n        // get diamond storage\r\n        assembly {\r\n            ds.slot := position\r\n        }\r\n        // get facet from function selector\r\n        address facet = address(bytes20(ds.facets[msg.sig]));\r\n        require(facet != address(0), \"Diamond: Function does not exist\");\r\n        // Execute external function from facet using delegatecall and return any value.\r\n        assembly {\r\n            // copy function selector and any arguments\r\n            calldatacopy(0, 0, calldatasize())\r\n            // execute function call using the facet\r\n            let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\r\n            // get any return value\r\n            returndatacopy(0, 0, returndatasize())\r\n            // return any return value or error back to the caller\r\n            switch result\r\n                case 0 {\r\n                    revert(0, returndatasize())\r\n                }\r\n                default {\r\n                    return(0, returndatasize())\r\n                }\r\n        }\r\n    }\r\n\r\n    receive() external payable {}\r\n}"
    },
    "contracts/diamond_base/facets/DiamondCutFacet.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.8.17;\r\n\r\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\r\nimport { LibDiamond } from \"../libraries/LibDiamond.sol\";\r\n\r\n// Remember to add the loupe functions from DiamondLoupeFacet to the diamond.\r\n// The loupe functions are required by the EIP2535 Diamonds standard\r\n\r\ncontract DiamondCutFacet is IDiamondCut {\r\n    /// @notice Add/replace/remove any number of functions and optionally execute\r\n    ///         a function with delegatecall\r\n    /// @param _diamondCut Contains the facet addresses and function selectors\r\n    /// @param _init The address of the contract or facet to execute _calldata\r\n    /// @param _calldata A function call, including function selector and arguments\r\n    ///                  _calldata is executed with delegatecall on _init\r\n    function diamondCut(\r\n        FacetCut[] calldata _diamondCut,\r\n        address _init,\r\n        bytes calldata _calldata\r\n    ) external override {\r\n        LibDiamond.enforceIsContractOwner();\r\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\r\n        uint256 originalSelectorCount = ds.selectorCount;\r\n        uint256 selectorCount = originalSelectorCount;\r\n        bytes32 selectorSlot;\r\n        // Check if last selector slot is not full\r\n        // \"selectorCount & 7\" is a gas efficient modulo by eight \"selectorCount % 8\" \r\n        if (selectorCount & 7 > 0) {\r\n            // get last selectorSlot\r\n            // \"selectorCount >> 3\" is a gas efficient division by 8 \"selectorCount / 8\"\r\n            selectorSlot = ds.selectorSlots[selectorCount >> 3];\r\n        }\r\n        // loop through diamond cut\r\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; ) {\r\n            (selectorCount, selectorSlot) = LibDiamond.addReplaceRemoveFacetSelectors(\r\n                selectorCount,\r\n                selectorSlot,\r\n                _diamondCut[facetIndex].facetAddress,\r\n                _diamondCut[facetIndex].action,\r\n                _diamondCut[facetIndex].functionSelectors\r\n            );\r\n\r\n            unchecked {\r\n                facetIndex++;\r\n            }\r\n        }\r\n        if (selectorCount != originalSelectorCount) {\r\n            ds.selectorCount = uint16(selectorCount);\r\n        }\r\n        // If last selector slot is not full\r\n        // \"selectorCount & 7\" is a gas efficient modulo by eight \"selectorCount % 8\" \r\n        if (selectorCount & 7 > 0) {\r\n            // \"selectorCount >> 3\" is a gas efficient division by 8 \"selectorCount / 8\"\r\n            ds.selectorSlots[selectorCount >> 3] = selectorSlot;\r\n        }\r\n        emit DiamondCut(_diamondCut, _init, _calldata);\r\n        LibDiamond.initializeDiamondCut(_init, _calldata);\r\n    }\r\n}"
    },
    "contracts/diamond_base/facets/DiamondLoupeFacet.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.8.17;\r\n\r\nimport { LibDiamond } from  \"../libraries/LibDiamond.sol\";\r\nimport { IDiamondLoupe } from \"../interfaces/IDiamondLoupe.sol\";\r\nimport { IERC165 } from \"@openzeppelin/contracts/interfaces/IERC165.sol\";\r\n\r\n// The functions in DiamondLoupeFacet MUST be added to a diamond.\r\n// The EIP-2535 Diamond standard requires these functions\r\n\r\ncontract DiamondLoupeFacet is IDiamondLoupe, IERC165 {\r\n    // Diamond Loupe Functions\r\n    ////////////////////////////////////////////////////////////////////\r\n    /// These functions are expected to be called frequently by tools.\r\n    //\r\n    // struct Facet {\r\n    //     address facetAddress;\r\n    //     bytes4[] functionSelectors;\r\n    // }\r\n    /// @notice Gets all facets and their selectors.\r\n    /// @return facets_ Facet\r\n    function facets() external override view returns (Facet[] memory facets_) {\r\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\r\n        facets_ = new Facet[](ds.selectorCount);\r\n        uint16[] memory numFacetSelectors = new uint16[](ds.selectorCount);\r\n        uint256 numFacets;\r\n        uint256 selectorIndex;\r\n        // loop through function selectors\r\n        for (uint256 slotIndex; selectorIndex < ds.selectorCount; slotIndex++) {\r\n            bytes32 slot = ds.selectorSlots[slotIndex];\r\n            for (uint256 selectorSlotIndex; selectorSlotIndex < 8; selectorSlotIndex++) {\r\n                selectorIndex++;\r\n                if (selectorIndex > ds.selectorCount) {\r\n                    break;\r\n                }\r\n                // \" << 5 is the same as multiplying by 32 ( * 32)\r\n                bytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\r\n                address facetAddress_ = address(bytes20(ds.facets[selector]));\r\n                bool continueLoop;\r\n                for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\r\n                    if (facets_[facetIndex].facetAddress == facetAddress_) {\r\n                        facets_[facetIndex].functionSelectors[numFacetSelectors[facetIndex]] = selector;\r\n                        // probably will never have more than 256 functions from one facet contract\r\n                        require(numFacetSelectors[facetIndex] < 255);\r\n                        numFacetSelectors[facetIndex]++;\r\n                        continueLoop = true;\r\n                        break;\r\n                    }\r\n                }\r\n                if (continueLoop) {\r\n                    continue;\r\n                }\r\n                facets_[numFacets].facetAddress = facetAddress_;\r\n                facets_[numFacets].functionSelectors = new bytes4[](ds.selectorCount);\r\n                facets_[numFacets].functionSelectors[0] = selector;\r\n                numFacetSelectors[numFacets] = 1;\r\n                numFacets++;\r\n            }\r\n        }\r\n        for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\r\n            uint256 numSelectors = numFacetSelectors[facetIndex];\r\n            bytes4[] memory selectors = facets_[facetIndex].functionSelectors;\r\n            // setting the number of selectors\r\n            assembly {\r\n                mstore(selectors, numSelectors)\r\n            }\r\n        }\r\n        // setting the number of facets\r\n        assembly {\r\n            mstore(facets_, numFacets)\r\n        }\r\n    }\r\n\r\n    /// @notice Gets all the function selectors supported by a specific facet.\r\n    /// @param _facet The facet address.\r\n    /// @return _facetFunctionSelectors The selectors associated with a facet address.\r\n    function facetFunctionSelectors(address _facet) external override view returns (bytes4[] memory _facetFunctionSelectors) {\r\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\r\n        uint256 numSelectors;\r\n        _facetFunctionSelectors = new bytes4[](ds.selectorCount);\r\n        uint256 selectorIndex;\r\n        // loop through function selectors\r\n        for (uint256 slotIndex; selectorIndex < ds.selectorCount; slotIndex++) {\r\n            bytes32 slot = ds.selectorSlots[slotIndex];\r\n            for (uint256 selectorSlotIndex; selectorSlotIndex < 8; selectorSlotIndex++) {\r\n                selectorIndex++;\r\n                if (selectorIndex > ds.selectorCount) {\r\n                    break;\r\n                }\r\n                // \" << 5 is the same as multiplying by 32 ( * 32)\r\n                bytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\r\n                address facet = address(bytes20(ds.facets[selector]));\r\n                if (_facet == facet) {\r\n                    _facetFunctionSelectors[numSelectors] = selector;\r\n                    numSelectors++;\r\n                }\r\n            }\r\n        }\r\n        // Set the number of selectors in the array\r\n        assembly {\r\n            mstore(_facetFunctionSelectors, numSelectors)\r\n        }\r\n    }\r\n\r\n    /// @notice Get all the facet addresses used by a diamond.\r\n    /// @return facetAddresses_\r\n    function facetAddresses() external override view returns (address[] memory facetAddresses_) {\r\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\r\n        facetAddresses_ = new address[](ds.selectorCount);\r\n        uint256 numFacets;\r\n        uint256 selectorIndex;\r\n        // loop through function selectors\r\n        for (uint256 slotIndex; selectorIndex < ds.selectorCount; slotIndex++) {\r\n            bytes32 slot = ds.selectorSlots[slotIndex];\r\n            for (uint256 selectorSlotIndex; selectorSlotIndex < 8; selectorSlotIndex++) {\r\n                selectorIndex++;\r\n                if (selectorIndex > ds.selectorCount) {\r\n                    break;\r\n                }\r\n                // \" << 5 is the same as multiplying by 32 ( * 32)\r\n                bytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\r\n                address facetAddress_ = address(bytes20(ds.facets[selector]));\r\n                bool continueLoop;\r\n                for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\r\n                    if (facetAddress_ == facetAddresses_[facetIndex]) {\r\n                        continueLoop = true;\r\n                        break;\r\n                    }\r\n                }\r\n                if (continueLoop) {                    \r\n                    continue;\r\n                }\r\n                facetAddresses_[numFacets] = facetAddress_;\r\n                numFacets++;\r\n            }\r\n        }\r\n        // Set the number of facet addresses in the array\r\n        assembly {\r\n            mstore(facetAddresses_, numFacets)\r\n        }\r\n    }\r\n\r\n    /// @notice Gets the facet that supports the given selector.\r\n    /// @dev If facet is not found return address(0).\r\n    /// @param _functionSelector The function selector.\r\n    /// @return facetAddress_ The facet address.\r\n    function facetAddress(bytes4 _functionSelector) external override view returns (address facetAddress_) {\r\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\r\n        facetAddress_ = address(bytes20(ds.facets[_functionSelector]));\r\n    }\r\n\r\n    // This implements ERC-165.\r\n    function supportsInterface(bytes4 _interfaceId) external override view returns (bool) {\r\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\r\n        return ds.supportedInterfaces[_interfaceId];\r\n    }\r\n}"
    },
    "contracts/diamond_base/facets/DiamondOwnershipFacet.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.8.17;\r\n\r\nimport { LibDiamond } from \"../libraries/LibDiamond.sol\";\r\nimport { IDiamondOwnership } from \"../interfaces/IDiamondOwnership.sol\";\r\n\r\ncontract DiamondOwnershipFacet is IDiamondOwnership {\r\n    function transferOwnership(address _newOwner) external override {\r\n        LibDiamond.enforceIsContractOwner();\r\n        LibDiamond.setContractOwner(_newOwner);\r\n    }\r\n\r\n    function owner() external override view returns (address owner_) {\r\n        owner_ = LibDiamond.contractOwner();\r\n    }\r\n}"
    },
    "contracts/diamond_base/interfaces/IDiamondCut.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.8.17;\r\n\r\ninterface IDiamondCut {\r\n    enum FacetCutAction {Add, Replace, Remove}\r\n    // Add=0, Replace=1, Remove=2\r\n\r\n    struct FacetCut {\r\n        address facetAddress;\r\n        FacetCutAction action;\r\n        bytes4[] functionSelectors;\r\n    }\r\n\r\n    /// @notice Add/replace/remove any number of functions and optionally execute\r\n    ///         a function with delegatecall\r\n    /// @param _diamondCut Contains the facet addresses and function selectors\r\n    /// @param _init The address of the contract or facet to execute _calldata\r\n    /// @param _calldata A function call, including function selector and arguments\r\n    ///                  _calldata is executed with delegatecall on _init\r\n    function diamondCut(\r\n        FacetCut[] calldata _diamondCut,\r\n        address _init,\r\n        bytes calldata _calldata\r\n    ) external;\r\n\r\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\r\n}"
    },
    "contracts/diamond_base/interfaces/IDiamondLoupe.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.8.17;\r\n\r\n// A loupe is a small magnifying glass used to look at diamonds.\r\n// These functions look at diamonds\r\ninterface IDiamondLoupe {\r\n    /// These functions are expected to be called frequently\r\n    /// by tools.\r\n\r\n    struct Facet {\r\n        address facetAddress;\r\n        bytes4[] functionSelectors;\r\n    }\r\n\r\n    /// @notice Gets all facet addresses and their four byte function selectors.\r\n    /// @return facets_ Facet\r\n    function facets() external view returns (Facet[] memory facets_);\r\n\r\n    /// @notice Gets all the function selectors supported by a specific facet.\r\n    /// @param _facet The facet address.\r\n    /// @return facetFunctionSelectors_\r\n    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);\r\n\r\n    /// @notice Get all the facet addresses used by a diamond.\r\n    /// @return facetAddresses_\r\n    function facetAddresses() external view returns (address[] memory facetAddresses_);\r\n\r\n    /// @notice Gets the facet that supports the given selector.\r\n    /// @dev If facet is not found return address(0).\r\n    /// @param _functionSelector The function selector.\r\n    /// @return facetAddress_ The facet address.\r\n    function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);\r\n}"
    },
    "contracts/diamond_base/interfaces/IDiamondOwnership.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.8.17;\r\nimport { IERC173 } from \"./IERC173.sol\";\r\n\r\ninterface IDiamondOwnership is IERC173 {}\r\n"
    },
    "contracts/diamond_base/interfaces/IERC173.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.8.17;\r\n\r\n/// @title ERC-173 Contract Ownership Standard\r\n///  Note: the ERC-165 identifier for this interface is 0x7f5828d0\r\n/* is ERC165 */\r\ninterface IERC173 {\r\n    /// @dev This emits when ownership of a contract changes.\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /// @notice Get the address of the owner\r\n    /// @return owner_ The address of the owner.\r\n    function owner() external view returns (address owner_);\r\n\r\n    /// @notice Set the address of the new owner of the contract\r\n    /// @dev Set _newOwner to address(0) to renounce any ownership.\r\n    /// @param _newOwner The address of the new owner of the contract\r\n    function transferOwnership(address _newOwner) external;\r\n}"
    },
    "contracts/diamond_base/libraries/LibDiamond.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.8.17;\r\n\r\n\r\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\r\n\r\n// Remember to add the loupe functions from DiamondLoupeFacet to the diamond.\r\n// The loupe functions are required by the EIP2535 Diamonds standard\r\n\r\nerror InitializationFunctionReverted(address _initializationContractAddress, bytes _calldata);\r\n\r\nlibrary LibDiamond {\r\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.standard.diamond.storage\");\r\n\r\n    struct DiamondStorage {\r\n        // maps function selectors to the facets that execute the functions.\r\n        // and maps the selectors to their position in the selectorSlots array.\r\n        // func selector => address facet, selector position\r\n        mapping(bytes4 => bytes32) facets;\r\n        // array of slots of function selectors.\r\n        // each slot holds 8 function selectors.\r\n        mapping(uint256 => bytes32) selectorSlots;\r\n        // The number of function selectors in selectorSlots\r\n        uint16 selectorCount;\r\n        // Used to query if a contract implements an interface.\r\n        // Used to implement ERC-165.\r\n        mapping(bytes4 => bool) supportedInterfaces;\r\n        // owner of the contract\r\n        address contractOwner;\r\n    }\r\n\r\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\r\n        bytes32 position = DIAMOND_STORAGE_POSITION;\r\n        assembly {\r\n            ds.slot := position\r\n        }\r\n    }\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    function setContractOwner(address _newOwner) internal {\r\n        DiamondStorage storage ds = diamondStorage();\r\n        address previousOwner = ds.contractOwner;\r\n        ds.contractOwner = _newOwner;\r\n        emit OwnershipTransferred(previousOwner, _newOwner);\r\n    }\r\n\r\n    function contractOwner() internal view returns (address contractOwner_) {\r\n        contractOwner_ = diamondStorage().contractOwner;\r\n    }\r\n\r\n    function enforceIsContractOwner() internal view {\r\n        require(msg.sender == diamondStorage().contractOwner, \"LibDiamond: Must be contract owner\");\r\n    }\r\n\r\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\r\n\r\n    bytes32 constant CLEAR_ADDRESS_MASK = bytes32(uint256(0xffffffffffffffffffffffff));\r\n    bytes32 constant CLEAR_SELECTOR_MASK = bytes32(uint256(0xffffffff << 224));\r\n\r\n    // Internal function version of diamondCut\r\n    // This code is almost the same as the external diamondCut,\r\n    // except it is using 'Facet[] memory _diamondCut' instead of\r\n    // 'Facet[] calldata _diamondCut'.\r\n    // The code is duplicated to prevent copying calldata to memory which\r\n    // causes an error for a two dimensional array.\r\n    function diamondCut(\r\n        IDiamondCut.FacetCut[] memory _diamondCut,\r\n        address _init,\r\n        bytes memory _calldata\r\n    ) internal {\r\n        DiamondStorage storage ds = diamondStorage();\r\n        uint256 originalSelectorCount = ds.selectorCount;\r\n        uint256 selectorCount = originalSelectorCount;\r\n        bytes32 selectorSlot;\r\n        // Check if last selector slot is not full\r\n        // \"selectorCount & 7\" is a gas efficient modulo by eight \"selectorCount % 8\" \r\n        if (selectorCount & 7 > 0) {\r\n            // get last selectorSlot\r\n            // \"selectorSlot >> 3\" is a gas efficient division by 8 \"selectorSlot / 8\"\r\n            selectorSlot = ds.selectorSlots[selectorCount >> 3];\r\n        }\r\n        // loop through diamond cut\r\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; ) {\r\n            (selectorCount, selectorSlot) = addReplaceRemoveFacetSelectors(\r\n                selectorCount,\r\n                selectorSlot,\r\n                _diamondCut[facetIndex].facetAddress,\r\n                _diamondCut[facetIndex].action,\r\n                _diamondCut[facetIndex].functionSelectors\r\n            );\r\n\r\n            unchecked {\r\n                facetIndex++;\r\n            }\r\n        }\r\n        if (selectorCount != originalSelectorCount) {\r\n            ds.selectorCount = uint16(selectorCount);\r\n        }\r\n        // If last selector slot is not full\r\n        // \"selectorCount & 7\" is a gas efficient modulo by eight \"selectorCount % 8\" \r\n        if (selectorCount & 7 > 0) {\r\n            // \"selectorSlot >> 3\" is a gas efficient division by 8 \"selectorSlot / 8\"\r\n            ds.selectorSlots[selectorCount >> 3] = selectorSlot;\r\n        }\r\n        emit DiamondCut(_diamondCut, _init, _calldata);\r\n        initializeDiamondCut(_init, _calldata);\r\n    }\r\n\r\n    function addReplaceRemoveFacetSelectors(\r\n        uint256 _selectorCount,\r\n        bytes32 _selectorSlot,\r\n        address _newFacetAddress,\r\n        IDiamondCut.FacetCutAction _action,\r\n        bytes4[] memory _selectors\r\n    ) internal returns (uint256, bytes32) {\r\n        DiamondStorage storage ds = diamondStorage();\r\n        require(_selectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\r\n        if (_action == IDiamondCut.FacetCutAction.Add) {\r\n            enforceHasContractCode(_newFacetAddress, \"LibDiamondCut: Add facet has no code\");\r\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; ) {\r\n                bytes4 selector = _selectors[selectorIndex];\r\n                bytes32 oldFacet = ds.facets[selector];\r\n                require(address(bytes20(oldFacet)) == address(0), \"LibDiamondCut: Can't add function that already exists\");\r\n                // add facet for selector\r\n                ds.facets[selector] = bytes20(_newFacetAddress) | bytes32(_selectorCount);\r\n                // \"_selectorCount & 7\" is a gas efficient modulo by eight \"_selectorCount % 8\" \r\n                // \" << 5 is the same as multiplying by 32 ( * 32)\r\n                uint256 selectorInSlotPosition = (_selectorCount & 7) << 5;\r\n                // clear selector position in slot and add selector\r\n                _selectorSlot = (_selectorSlot & ~(CLEAR_SELECTOR_MASK >> selectorInSlotPosition)) | (bytes32(selector) >> selectorInSlotPosition);\r\n                // if slot is full then write it to storage\r\n                if (selectorInSlotPosition == 224) {\r\n                    // \"_selectorSlot >> 3\" is a gas efficient division by 8 \"_selectorSlot / 8\"\r\n                    ds.selectorSlots[_selectorCount >> 3] = _selectorSlot;\r\n                    _selectorSlot = 0;\r\n                }\r\n                _selectorCount++;\r\n\r\n                unchecked {\r\n                    selectorIndex++;\r\n                }\r\n            }\r\n        } else if (_action == IDiamondCut.FacetCutAction.Replace) {\r\n            enforceHasContractCode(_newFacetAddress, \"LibDiamondCut: Replace facet has no code\");\r\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; ) {\r\n                bytes4 selector = _selectors[selectorIndex];\r\n                bytes32 oldFacet = ds.facets[selector];\r\n                address oldFacetAddress = address(bytes20(oldFacet));\r\n                // only useful if immutable functions exist\r\n                // require(oldFacetAddress != address(this), \"LibDiamondCut: Can't replace immutable function\");\r\n                require(oldFacetAddress != _newFacetAddress, \"LibDiamondCut: Can't replace function with same function\");\r\n                require(oldFacetAddress != address(0), \"LibDiamondCut: Can't replace function that doesn't exist\");\r\n                // replace old facet address\r\n                ds.facets[selector] = (oldFacet & CLEAR_ADDRESS_MASK) | bytes20(_newFacetAddress);\r\n\r\n                unchecked {\r\n                    selectorIndex++;\r\n                }\r\n            }\r\n        } else if (_action == IDiamondCut.FacetCutAction.Remove) {\r\n            require(_newFacetAddress == address(0), \"LibDiamondCut: Remove facet address must be address(0)\");\r\n            // \"_selectorCount >> 3\" is a gas efficient division by 8 \"_selectorCount / 8\"\r\n            uint256 selectorSlotCount = _selectorCount >> 3;\r\n            // \"_selectorCount & 7\" is a gas efficient modulo by eight \"_selectorCount % 8\" \r\n            uint256 selectorInSlotIndex = _selectorCount & 7;\r\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; ) {\r\n                if (_selectorSlot == 0) {\r\n                    // get last selectorSlot\r\n                    selectorSlotCount--;\r\n                    _selectorSlot = ds.selectorSlots[selectorSlotCount];\r\n                    selectorInSlotIndex = 7;\r\n                } else {\r\n                    selectorInSlotIndex--;\r\n                }\r\n                bytes4 lastSelector;\r\n                uint256 oldSelectorsSlotCount;\r\n                uint256 oldSelectorInSlotPosition;\r\n                // adding a block here prevents stack too deep error\r\n                {\r\n                    bytes4 selector = _selectors[selectorIndex];\r\n                    bytes32 oldFacet = ds.facets[selector];\r\n                    require(address(bytes20(oldFacet)) != address(0), \"LibDiamondCut: Can't remove function that doesn't exist\");\r\n                    // only useful if immutable functions exist\r\n                    require(address(bytes20(oldFacet)) != address(this), \"LibDiamondCut: Can't remove immutable function\");\r\n                    // replace selector with last selector in ds.facets\r\n                    // gets the last selector\r\n                    // \" << 5 is the same as multiplying by 32 ( * 32)\r\n                    lastSelector = bytes4(_selectorSlot << (selectorInSlotIndex << 5));\r\n                    if (lastSelector != selector) {\r\n                        // update last selector slot position info\r\n                        ds.facets[lastSelector] = (oldFacet & CLEAR_ADDRESS_MASK) | bytes20(ds.facets[lastSelector]);\r\n                    }\r\n                    delete ds.facets[selector];\r\n                    uint256 oldSelectorCount = uint16(uint256(oldFacet));\r\n                    // \"oldSelectorCount >> 3\" is a gas efficient division by 8 \"oldSelectorCount / 8\"\r\n                    oldSelectorsSlotCount = oldSelectorCount >> 3;\r\n                    // \"oldSelectorCount & 7\" is a gas efficient modulo by eight \"oldSelectorCount % 8\" \r\n                    // \" << 5 is the same as multiplying by 32 ( * 32)\r\n                    oldSelectorInSlotPosition = (oldSelectorCount & 7) << 5;\r\n                }\r\n                if (oldSelectorsSlotCount != selectorSlotCount) {\r\n                    bytes32 oldSelectorSlot = ds.selectorSlots[oldSelectorsSlotCount];\r\n                    // clears the selector we are deleting and puts the last selector in its place.\r\n                    oldSelectorSlot =\r\n                        (oldSelectorSlot & ~(CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) |\r\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\r\n                    // update storage with the modified slot\r\n                    ds.selectorSlots[oldSelectorsSlotCount] = oldSelectorSlot;\r\n                } else {\r\n                    // clears the selector we are deleting and puts the last selector in its place.\r\n                    _selectorSlot =\r\n                        (_selectorSlot & ~(CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) |\r\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\r\n                }\r\n                if (selectorInSlotIndex == 0) {\r\n                    delete ds.selectorSlots[selectorSlotCount];\r\n                    _selectorSlot = 0;\r\n                }\r\n\r\n                unchecked {\r\n                    selectorIndex++;\r\n                }\r\n            }\r\n            _selectorCount = selectorSlotCount * 8 + selectorInSlotIndex;\r\n        } else {\r\n            revert(\"LibDiamondCut: Incorrect FacetCutAction\");\r\n        }\r\n        return (_selectorCount, _selectorSlot);\r\n    }\r\n\r\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\r\n        if (_init == address(0)) {\r\n            return;\r\n        }\r\n        enforceHasContractCode(_init, \"LibDiamondCut: _init address has no code\");        \r\n        (bool success, bytes memory error) = _init.delegatecall(_calldata);\r\n        if (!success) {\r\n            if (error.length > 0) {\r\n                // bubble up error\r\n                /// @solidity memory-safe-assembly\r\n                assembly {\r\n                    let returndata_size := mload(error)\r\n                    revert(add(32, error), returndata_size)\r\n                }\r\n            } else {\r\n                revert InitializationFunctionReverted(_init, _calldata);\r\n            }\r\n        }\r\n    }\r\n\r\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\r\n        uint256 contractSize;\r\n        assembly {\r\n            contractSize := extcodesize(_contract)\r\n        }\r\n        require(contractSize > 0, _errorMessage);\r\n    }\r\n}"
    },
    "contracts/diamond_base/upgradeInitializers/DiamondInit.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.8.17;\r\n\r\nimport { LibDiamond } from \"../libraries/LibDiamond.sol\";\r\nimport { IDiamondLoupe } from \"../interfaces/IDiamondLoupe.sol\";\r\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\r\nimport { IERC173 } from \"../interfaces/IERC173.sol\";\r\nimport { IERC165 } from \"@openzeppelin/contracts/interfaces/IERC165.sol\";\r\n\r\n// It is expected that this contract is customized if you want to deploy your diamond\r\n// with data from a deployment script. Use the init function to initialize state variables\r\n// of your diamond. Add parameters to the init funciton if you need to.\r\n\r\n// Adding parameters to the `init` or other functions you add here can make a single deployed\r\n// DiamondInit contract reusable accross upgrades, and can be used for multiple diamonds.\r\n\r\ncontract DiamondInit {    \r\n\r\n    // You can add parameters to this function in order to pass in \r\n    // data to set your own state variables\r\n    function init() external {\r\n        // adding ERC165 data\r\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\r\n        ds.supportedInterfaces[type(IERC165).interfaceId] = true;\r\n        ds.supportedInterfaces[type(IDiamondCut).interfaceId] = true;\r\n        ds.supportedInterfaces[type(IDiamondLoupe).interfaceId] = true;\r\n        ds.supportedInterfaces[type(IERC173).interfaceId] = true;\r\n\r\n        // add your own state variables \r\n        // EIP-2535 specifies that the `diamondCut` function takes two optional \r\n        // arguments: address _init and bytes calldata _calldata\r\n        // These arguments are used to execute an arbitrary function using delegatecall\r\n        // in order to set state variables in the diamond during deployment or an upgrade\r\n        // More info here: https://eips.ethereum.org/EIPS/eip-2535#diamond-interface \r\n    }\r\n}"
    },
    "contracts/universal_bridge/libraries/LibChainInfo.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.8.17;\r\n\r\nlibrary LibChainInfo {\r\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\"LibChainInfo.storage\");\r\n\r\n    struct ChainInfoStorage {\r\n        string chainName;\r\n        bool isProxyChain;\r\n    }\r\n\r\n    function diamondStorage() internal pure returns (ChainInfoStorage storage ds) {\r\n        bytes32 position = DIAMOND_STORAGE_POSITION;\r\n        assembly {\r\n            ds.slot := position\r\n        }\r\n    }\r\n\r\n    function chainName() internal view returns (string memory) {\r\n        return diamondStorage().chainName;\r\n    }\r\n\r\n    function setChainName(string memory _chainName) internal {\r\n        diamondStorage().chainName = _chainName;\r\n    }\r\n\r\n    function isProxyChain() internal view returns (bool) {\r\n        return diamondStorage().isProxyChain;\r\n    }\r\n\r\n    function setIsProxyChain(bool _isProxyChain) internal {\r\n        diamondStorage().isProxyChain = _isProxyChain;\r\n    }\r\n}\r\n"
    },
    "contracts/universal_bridge/libraries/LibValidatorController.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.8.17;\r\n\r\nlibrary LibValidatorController {\r\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\"validatorController.storage\");\r\n\r\n    struct ValidatorControllerStorage {\r\n        address validator;\r\n    }\r\n\r\n    function diamondStorage() internal pure returns (ValidatorControllerStorage storage ds) {\r\n        bytes32 position = DIAMOND_STORAGE_POSITION;\r\n        assembly {\r\n            ds.slot := position\r\n        }\r\n    }\r\n\r\n    event ValidatorTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    function enforceIsValidator() internal view {\r\n        require(\r\n            msg.sender == diamondStorage().validator,\r\n            \"LibValidatorController: Must be validator\"\r\n        );\r\n    }\r\n\r\n    function setValidator(address _newValidator) internal {\r\n        ValidatorControllerStorage storage ds = diamondStorage();\r\n        address previousValidator = ds.validator;\r\n        ds.validator = _newValidator;\r\n        emit ValidatorTransferred(previousValidator, _newValidator);\r\n    }\r\n\r\n    function validator() internal view returns (address) {\r\n        return diamondStorage().validator;\r\n    }\r\n}\r\n"
    },
    "contracts/universal_bridge/UniversalBridgeDiamond.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.8.17;\r\n\r\nimport { Diamond } from \"../diamond_base/Diamond.sol\";\r\nimport { LibChainInfo } from \"./libraries/LibChainInfo.sol\";\r\nimport { LibValidatorController } from \"./libraries/LibValidatorController.sol\";\r\n\r\ncontract UniversalBridgeDiamond is Diamond {\r\n    constructor(\r\n        string memory _chainName,\r\n        bool _isProxyChain,\r\n        address _contractOwner,\r\n        address _diamondCutFacet,\r\n        address _validator\r\n    ) Diamond(_contractOwner, _diamondCutFacet) {\r\n        LibChainInfo.setChainName(_chainName);\r\n        LibChainInfo.setIsProxyChain(_isProxyChain);\r\n        LibValidatorController.setValidator(_validator);\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "viaIR": true,
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}